"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitHubExportService = void 0;
const BaseService_1 = require("./BaseService");
const GitHubService_1 = require("./GitHubService");
const AppManagementService_1 = require("./AppManagementService");
const firestore_1 = require("firebase-admin/firestore");
/**
 * GitHub Export Service
 * Handles exporting Stich apps to GitHub repositories
 */
class GitHubExportService extends BaseService_1.BaseService {
    constructor() {
        super();
        this.db = (0, firestore_1.getFirestore)();
        this.githubService = new GitHubService_1.GitHubService();
        this.appService = new AppManagementService_1.AppManagementService();
    }
    /**
     * Export a Stich app to GitHub repository
     */
    async exportAppToGitHub(userId, config) {
        try {
            // Verify user has GitHub connected
            const token = await this.githubService.getUserToken(userId);
            if (!token) {
                return {
                    success: false,
                    error: 'GitHub not connected. Please connect your GitHub account first.',
                };
            }
            // Get app data
            const app = await this.appService.getApplicationById(config.appId);
            if (!app) {
                return {
                    success: false,
                    error: 'Application not found',
                };
            }
            // Verify user owns the app or it's public
            if (app.createdBy !== userId && !app.isPublic) {
                return {
                    success: false,
                    error: 'Access denied. You can only export your own apps or public apps.',
                };
            }
            // Get app files from storage
            const appFiles = await this.getAppFiles(config.appId);
            // Prepare repository files
            const repositoryFiles = await this.prepareRepositoryFiles(app, appFiles, config);
            // Create GitHub repository
            const repository = await this.githubService.createRepository(token, config.repositoryName, config.description || `${app.name} - Generated by Stich Production`, config.isPrivate);
            // Push files to repository
            await this.githubService.pushFiles(token, repository.full_name, repositoryFiles, config.customCommitMessage || `Initial commit: Export ${app.name} from Stich`);
            // Record export in database
            await this.recordExport(userId, config.appId, repository);
            this.logger.info('App exported to GitHub successfully', {
                userId,
                appId: config.appId,
                repository: repository.full_name,
                fileCount: repositoryFiles.length,
            });
            return {
                success: true,
                repository: {
                    id: repository.id,
                    name: repository.name,
                    full_name: repository.full_name,
                    html_url: repository.html_url,
                    clone_url: repository.clone_url,
                },
                fileCount: repositoryFiles.length,
            };
        }
        catch (error) {
            this.logger.error('Failed to export app to GitHub', {
                userId,
                appId: config.appId,
                error,
            });
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Export failed',
            };
        }
    }
    /**
     * Get app files from storage or generation data
     */
    async getAppFiles(appId) {
        try {
            // Get app generation data
            const appDoc = await this.db.collection('apps').doc(appId).get();
            if (!appDoc.exists) {
                throw new Error('App not found');
            }
            const appData = appDoc.data();
            const files = [];
            // Get files from generation data or storage
            if (appData.files) {
                // Files stored in generation data
                Object.entries(appData.files).forEach(([path, content]) => {
                    files.push({
                        path,
                        content: content,
                    });
                });
            }
            else if (appData.generationId) {
                // Get files from generation collection
                const generationDoc = await this.db
                    .collection('generations')
                    .doc(appData.generationId)
                    .get();
                if (generationDoc.exists) {
                    const generationData = generationDoc.data();
                    if (generationData.files) {
                        Object.entries(generationData.files).forEach(([path, content]) => {
                            files.push({
                                path,
                                content: content,
                            });
                        });
                    }
                }
            }
            return files;
        }
        catch (error) {
            this.logger.error('Failed to get app files', { appId, error });
            throw new Error('Failed to retrieve app files');
        }
    }
    /**
     * Prepare files for GitHub repository
     */
    async prepareRepositoryFiles(app, appFiles, config) {
        const files = [...appFiles];
        // Add README.md if not present
        const hasReadme = files.some(f => f.path.toLowerCase() === 'readme.md');
        if (!hasReadme) {
            files.push({
                path: 'README.md',
                content: this.generateReadmeContent(app, config),
            });
        }
        // Add package.json if not present (for Node.js apps)
        const hasPackageJson = files.some(f => f.path === 'package.json');
        if (!hasPackageJson && this.isNodeJsApp(files)) {
            files.push({
                path: 'package.json',
                content: this.generatePackageJsonContent(app, config),
            });
        }
        // Add .gitignore if not present
        const hasGitignore = files.some(f => f.path === '.gitignore');
        if (!hasGitignore) {
            files.push({
                path: '.gitignore',
                content: this.generateGitignoreContent(files),
            });
        }
        // Add deployment configuration
        files.push({
            path: '.stichrc.json',
            content: JSON.stringify({
                name: app.name,
                description: app.description,
                framework: app.framework,
                originalAppId: app.id,
                exportedAt: new Date().toISOString(),
                exportedBy: 'Stich Production',
                version: '1.0.0',
            }, null, 2),
        });
        return files;
    }
    /**
     * Generate README.md content
     */
    generateReadmeContent(app, config) {
        var _a, _b, _c, _d, _e;
        return `# ${app.name}

${app.description}

## ðŸš€ Generated by Stich Production

This application was generated using [Stich Production](https://stich.ai), an AI-powered web application generator.

### Framework
- **Framework**: ${app.framework}
- **Generated**: ${new Date(((_b = (_a = app.createdAt) === null || _a === void 0 ? void 0 : _a.toDate) === null || _b === void 0 ? void 0 : _b.call(_a)) || app.createdAt).toLocaleDateString()}

### Getting Started

\`\`\`bash
# Install dependencies
npm install

# Start development server
npm run dev

# Build for production
npm run build
\`\`\`

### Features
${((_c = app.features) === null || _c === void 0 ? void 0 : _c.map((feature) => `- ${feature}`).join('\n')) || '- Generated with AI assistance'}

### Deployment
This app can be deployed to various platforms:
- Vercel
- Netlify
- Firebase Hosting
- GitHub Pages

### Original App
- **App ID**: ${app.id}
- **Created**: ${new Date(((_e = (_d = app.createdAt) === null || _d === void 0 ? void 0 : _d.toDate) === null || _e === void 0 ? void 0 : _e.call(_d)) || app.createdAt).toLocaleDateString()}

---

*Built with â¤ï¸ using [Stich Production](https://stich.ai)*
`;
    }
    /**
     * Generate package.json content
     */
    generatePackageJsonContent(app, config) {
        var _a;
        const packageName = config.repositoryName.toLowerCase().replace(/[^a-z0-9-]/g, '-');
        return JSON.stringify({
            name: packageName,
            version: '1.0.0',
            description: app.description || `${app.name} - Generated by Stich Production`,
            main: 'index.js',
            scripts: {
                dev: 'npm run start:dev',
                start: 'npm run start:prod',
                build: 'npm run build:prod',
                'start:dev': 'node server.js',
                'start:prod': 'node server.js',
                'build:prod': 'echo "Build completed"',
            },
            keywords: [
                'stich',
                'ai-generated',
                (_a = app.framework) === null || _a === void 0 ? void 0 : _a.toLowerCase(),
                'web-app',
            ].filter(Boolean),
            author: 'Generated by Stich Production',
            license: 'MIT',
            dependencies: {
                express: '^4.18.2',
            },
            devDependencies: {},
            engines: {
                node: '>=16.0.0',
                npm: '>=8.0.0',
            },
        }, null, 2);
    }
    /**
     * Generate .gitignore content
     */
    generateGitignoreContent(files) {
        const baseIgnore = `# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Build outputs
dist/
build/
out/

# Cache
.cache/
.parcel-cache/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
logs
*.log

# Temporary files
tmp/
temp/
`;
        // Add framework-specific ignores
        const hasReact = files.some(f => f.content.includes('react'));
        const hasNext = files.some(f => f.content.includes('next'));
        const hasVue = files.some(f => f.content.includes('vue'));
        let frameworkIgnore = '';
        if (hasNext) {
            frameworkIgnore += '\n# Next.js\n.next/\n';
        }
        if (hasReact || hasVue) {
            frameworkIgnore += '\n# Build\nbuild/\n';
        }
        return baseIgnore + frameworkIgnore;
    }
    /**
     * Check if app is a Node.js application
     */
    isNodeJsApp(files) {
        return files.some(f => f.path.endsWith('.js') ||
            f.path.endsWith('.ts') ||
            f.content.includes('require(') ||
            f.content.includes('import '));
    }
    /**
     * Record export in database
     */
    async recordExport(userId, appId, repository) {
        try {
            await this.db.collection('exports').add({
                userId,
                appId,
                repositoryId: repository.id,
                repositoryName: repository.name,
                repositoryFullName: repository.full_name,
                repositoryUrl: repository.html_url,
                cloneUrl: repository.clone_url,
                createdAt: new Date(),
            });
            // Update app with export info
            await this.db.collection('apps').doc(appId).update({
                lastExportedAt: new Date(),
                exportedToGitHub: true,
                githubRepository: {
                    id: repository.id,
                    name: repository.name,
                    full_name: repository.full_name,
                    html_url: repository.html_url,
                },
            });
        }
        catch (error) {
            this.logger.error('Failed to record export', { userId, appId, error });
            // Don't throw error as export succeeded, just logging failed
        }
    }
    /**
     * Get user's export history
     */
    async getUserExports(userId, page = 1, limit = 10) {
        var _a, _b;
        try {
            const offset = (page - 1) * limit;
            const query = this.db
                .collection('exports')
                .where('userId', '==', userId)
                .orderBy('createdAt', 'desc')
                .limit(limit + 1)
                .offset(offset);
            const snapshot = await query.get();
            const exports = [];
            for (const doc of snapshot.docs.slice(0, limit)) {
                const data = doc.data();
                exports.push({
                    id: doc.id,
                    ...data,
                    createdAt: ((_b = (_a = data.createdAt) === null || _a === void 0 ? void 0 : _a.toDate) === null || _b === void 0 ? void 0 : _b.call(_a)) || data.createdAt,
                });
            }
            const hasMore = snapshot.docs.length > limit;
            return {
                exports,
                total: exports.length,
                hasMore,
            };
        }
        catch (error) {
            this.logger.error('Failed to get user exports', { userId, error });
            throw new Error('Failed to retrieve export history');
        }
    }
}
exports.GitHubExportService = GitHubExportService;
//# sourceMappingURL=GitHubExportService.js.map