import { BaseService } from './BaseService';
import { GitHubService } from './GitHubService';
import { AppManagementService } from './AppManagementService';
import { getFirestore } from 'firebase-admin/firestore';
import { logger } from 'firebase-functions';

export interface AppExportConfig {
  appId: string;
  repositoryName: string;
  description?: string;
  isPrivate: boolean;
  includeAssets: boolean;
  customCommitMessage?: string;
}

export interface ExportResult {
  success: boolean;
  repository?: {
    id: number;
    name: string;
    full_name: string;
    html_url: string;
    clone_url: string;
  };
  fileCount?: number;
  error?: string;
}

/**
 * GitHub Export Service
 * Handles exporting Stich apps to GitHub repositories
 */
export class GitHubExportService extends BaseService {
  protected db: any;
  private githubService: GitHubService;
  private appService: AppManagementService;

  constructor() {
    super();
    this.db = getFirestore();
    this.githubService = new GitHubService();
    this.appService = new AppManagementService();
  }

  /**
   * Export a Stich app to GitHub repository
   */
  async exportAppToGitHub(
    userId: string,
    config: AppExportConfig
  ): Promise<ExportResult> {
    try {
      // Verify user has GitHub connected
      const token = await this.githubService.getUserToken(userId);
      if (!token) {
        return {
          success: false,
          error: 'GitHub not connected. Please connect your GitHub account first.',
        };
      }

      // Get app data
      const app = await this.appService.getApplicationById(config.appId);
      if (!app) {
        return {
          success: false,
          error: 'Application not found',
        };
      }

      // Verify user owns the app or it's public
      if (app.createdBy !== userId && !app.isPublic) {
        return {
          success: false,
          error: 'Access denied. You can only export your own apps or public apps.',
        };
      }

      // Get app files from storage
      const appFiles = await this.getAppFiles(config.appId);
      
      // Prepare repository files
      const repositoryFiles = await this.prepareRepositoryFiles(app, appFiles, config);

      // Create GitHub repository
      const repository = await this.githubService.createRepository(
        token,
        config.repositoryName,
        config.description || `${app.name} - Generated by Stich Production`,
        config.isPrivate
      );

      // Push files to repository
      await this.githubService.pushFiles(
        token,
        repository.full_name,
        repositoryFiles,
        config.customCommitMessage || `Initial commit: Export ${app.name} from Stich`
      );

      // Record export in database
      await this.recordExport(userId, config.appId, repository);

      this.logger.info('App exported to GitHub successfully', {
        userId,
        appId: config.appId,
        repository: repository.full_name,
        fileCount: repositoryFiles.length,
      });

      return {
        success: true,
        repository: {
          id: repository.id,
          name: repository.name,
          full_name: repository.full_name,
          html_url: repository.html_url,
          clone_url: repository.clone_url,
        },
        fileCount: repositoryFiles.length,
      };
    } catch (error) {
      this.logger.error('Failed to export app to GitHub', {
        userId,
        appId: config.appId,
        error,
      });

      return {
        success: false,
        error: error instanceof Error ? error.message : 'Export failed',
      };
    }
  }

  /**
   * Get app files from storage or generation data
   */
  private async getAppFiles(appId: string): Promise<{ path: string; content: string; }[]> {
    try {
      // Get app generation data
      const appDoc = await this.db.collection('apps').doc(appId).get();
      if (!appDoc.exists) {
        throw new Error('App not found');
      }

      const appData = appDoc.data();
      const files: { path: string; content: string; }[] = [];

      // Get files from generation data or storage
      if (appData.files) {
        // Files stored in generation data
        Object.entries(appData.files).forEach(([path, content]) => {
          files.push({
            path,
            content: content as string,
          });
        });
      } else if (appData.generationId) {
        // Get files from generation collection
        const generationDoc = await this.db
          .collection('generations')
          .doc(appData.generationId)
          .get();

        if (generationDoc.exists) {
          const generationData = generationDoc.data();
          if (generationData.files) {
            Object.entries(generationData.files).forEach(([path, content]) => {
              files.push({
                path,
                content: content as string,
              });
            });
          }
        }
      }

      return files;
    } catch (error) {
      this.logger.error('Failed to get app files', { appId, error });
      throw new Error('Failed to retrieve app files');
    }
  }

  /**
   * Prepare files for GitHub repository
   */
  private async prepareRepositoryFiles(
    app: any,
    appFiles: { path: string; content: string; }[],
    config: AppExportConfig
  ): Promise<{ path: string; content: string; }[]> {
    const files: { path: string; content: string; }[] = [...appFiles];

    // Add README.md if not present
    const hasReadme = files.some(f => f.path.toLowerCase() === 'readme.md');
    if (!hasReadme) {
      files.push({
        path: 'README.md',
        content: this.generateReadmeContent(app, config),
      });
    }

    // Add package.json if not present (for Node.js apps)
    const hasPackageJson = files.some(f => f.path === 'package.json');
    if (!hasPackageJson && this.isNodeJsApp(files)) {
      files.push({
        path: 'package.json',
        content: this.generatePackageJsonContent(app, config),
      });
    }

    // Add .gitignore if not present
    const hasGitignore = files.some(f => f.path === '.gitignore');
    if (!hasGitignore) {
      files.push({
        path: '.gitignore',
        content: this.generateGitignoreContent(files),
      });
    }

    // Add deployment configuration
    files.push({
      path: '.stichrc.json',
      content: JSON.stringify({
        name: app.name,
        description: app.description,
        framework: app.framework,
        originalAppId: app.id,
        exportedAt: new Date().toISOString(),
        exportedBy: 'Stich Production',
        version: '1.0.0',
      }, null, 2),
    });

    return files;
  }

  /**
   * Generate README.md content
   */
  private generateReadmeContent(app: any, config: AppExportConfig): string {
    return `# ${app.name}

${app.description}

## 🚀 Generated by Stich Production

This application was generated using [Stich Production](https://stich.ai), an AI-powered web application generator.

### Framework
- **Framework**: ${app.framework}
- **Generated**: ${new Date(app.createdAt?.toDate?.() || app.createdAt).toLocaleDateString()}

### Getting Started

\`\`\`bash
# Install dependencies
npm install

# Start development server
npm run dev

# Build for production
npm run build
\`\`\`

### Features
${app.features?.map((feature: string) => `- ${feature}`).join('\n') || '- Generated with AI assistance'}

### Deployment
This app can be deployed to various platforms:
- Vercel
- Netlify
- Firebase Hosting
- GitHub Pages

### Original App
- **App ID**: ${app.id}
- **Created**: ${new Date(app.createdAt?.toDate?.() || app.createdAt).toLocaleDateString()}

---

*Built with ❤️ using [Stich Production](https://stich.ai)*
`;
  }

  /**
   * Generate package.json content
   */
  private generatePackageJsonContent(app: any, config: AppExportConfig): string {
    const packageName = config.repositoryName.toLowerCase().replace(/[^a-z0-9-]/g, '-');
    
    return JSON.stringify({
      name: packageName,
      version: '1.0.0',
      description: app.description || `${app.name} - Generated by Stich Production`,
      main: 'index.js',
      scripts: {
        dev: 'npm run start:dev',
        start: 'npm run start:prod',
        build: 'npm run build:prod',
        'start:dev': 'node server.js',
        'start:prod': 'node server.js',
        'build:prod': 'echo "Build completed"',
      },
      keywords: [
        'stich',
        'ai-generated',
        app.framework?.toLowerCase(),
        'web-app',
      ].filter(Boolean),
      author: 'Generated by Stich Production',
      license: 'MIT',
      dependencies: {
        express: '^4.18.2',
      },
      devDependencies: {},
      engines: {
        node: '>=16.0.0',
        npm: '>=8.0.0',
      },
    }, null, 2);
  }

  /**
   * Generate .gitignore content
   */
  private generateGitignoreContent(files: { path: string; content: string; }[]): string {
    const baseIgnore = `# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Build outputs
dist/
build/
out/

# Cache
.cache/
.parcel-cache/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
logs
*.log

# Temporary files
tmp/
temp/
`;

    // Add framework-specific ignores
    const hasReact = files.some(f => f.content.includes('react'));
    const hasNext = files.some(f => f.content.includes('next'));
    const hasVue = files.some(f => f.content.includes('vue'));

    let frameworkIgnore = '';
    if (hasNext) {
      frameworkIgnore += '\n# Next.js\n.next/\n';
    }
    if (hasReact || hasVue) {
      frameworkIgnore += '\n# Build\nbuild/\n';
    }

    return baseIgnore + frameworkIgnore;
  }

  /**
   * Check if app is a Node.js application
   */
  private isNodeJsApp(files: { path: string; content: string; }[]): boolean {
    return files.some(f => 
      f.path.endsWith('.js') || 
      f.path.endsWith('.ts') || 
      f.content.includes('require(') ||
      f.content.includes('import ')
    );
  }

  /**
   * Record export in database
   */
  private async recordExport(userId: string, appId: string, repository: any): Promise<void> {
    try {
      await this.db.collection('exports').add({
        userId,
        appId,
        repositoryId: repository.id,
        repositoryName: repository.name,
        repositoryFullName: repository.full_name,
        repositoryUrl: repository.html_url,
        cloneUrl: repository.clone_url,
        createdAt: new Date(),
      });

      // Update app with export info
      await this.db.collection('apps').doc(appId).update({
        lastExportedAt: new Date(),
        exportedToGitHub: true,
        githubRepository: {
          id: repository.id,
          name: repository.name,
          full_name: repository.full_name,
          html_url: repository.html_url,
        },
      });
    } catch (error) {
      this.logger.error('Failed to record export', { userId, appId, error });
      // Don't throw error as export succeeded, just logging failed
    }
  }

  /**
   * Get user's export history
   */
  async getUserExports(userId: string, page: number = 1, limit: number = 10): Promise<{
    exports: any[];
    total: number;
    hasMore: boolean;
  }> {
    try {
      const offset = (page - 1) * limit;
      
      const query = this.db
        .collection('exports')
        .where('userId', '==', userId)
        .orderBy('createdAt', 'desc')
        .limit(limit + 1)
        .offset(offset);

      const snapshot = await query.get();
      const exports = [];
      
      for (const doc of snapshot.docs.slice(0, limit)) {
        const data = doc.data();
        exports.push({
          id: doc.id,
          ...data,
          createdAt: data.createdAt?.toDate?.() || data.createdAt,
        });
      }

      const hasMore = snapshot.docs.length > limit;

      return {
        exports,
        total: exports.length,
        hasMore,
      };
    } catch (error) {
      this.logger.error('Failed to get user exports', { userId, error });
      throw new Error('Failed to retrieve export history');
    }
  }
}