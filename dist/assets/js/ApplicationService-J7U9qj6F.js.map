{"version":3,"file":"ApplicationService-J7U9qj6F.js","sources":["../../../src/services/application/ApplicationService.ts"],"sourcesContent":["import { \r\n  where, \r\n  orderBy, \r\n  limit as firestoreLimit,\r\n  QueryConstraint \r\n} from 'firebase/firestore';\r\nimport { BaseService } from '../core/BaseService';\r\n\r\n// Application data types\r\nexport interface Application {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  category: string;\r\n  framework: 'react' | 'vue' | 'svelte' | 'vanilla' | 'node' | 'python' | 'other';\r\n  status: 'draft' | 'generating' | 'building' | 'deployed' | 'failed';\r\n  isPublic: boolean;\r\n  isFavorite: boolean;\r\n  tags: string[];\r\n  \r\n  // URLs and deployment info\r\n  repositoryUrl?: string;\r\n  deploymentUrl?: string;\r\n  previewUrl?: string;\r\n  \r\n  // Generation metadata\r\n  generationSettings: {\r\n    aiProvider: 'openai' | 'anthropic' | 'google' | 'cerebras';\r\n    model: string;\r\n    prompt: string;\r\n    additionalInstructions?: string;\r\n  };\r\n  \r\n  // Analytics\r\n  analytics: {\r\n    views: number;\r\n    likes: number;\r\n    forks: number;\r\n    shares: number;\r\n  };\r\n  \r\n  // Audit fields\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  createdBy: string;\r\n  updatedBy: string;\r\n}\r\n\r\nexport interface CreateApplicationData {\r\n  name: string;\r\n  description: string;\r\n  category: string;\r\n  framework: Application['framework'];\r\n  isPublic?: boolean;\r\n  tags?: string[];\r\n  generationSettings: Application['generationSettings'];\r\n}\r\n\r\nexport interface UpdateApplicationData {\r\n  name?: string;\r\n  description?: string;\r\n  category?: string;\r\n  framework?: Application['framework'];\r\n  status?: Application['status'];\r\n  isPublic?: boolean;\r\n  isFavorite?: boolean;\r\n  tags?: string[];\r\n  repositoryUrl?: string;\r\n  deploymentUrl?: string;\r\n  previewUrl?: string;\r\n  generationSettings?: Partial<Application['generationSettings']>;\r\n}\r\n\r\nexport interface ApplicationFilters {\r\n  category?: string;\r\n  framework?: string;\r\n  status?: string;\r\n  isPublic?: boolean;\r\n  tags?: string[];\r\n  createdBy?: string;\r\n}\r\n\r\nexport interface ApplicationSearchOptions {\r\n  searchTerm?: string;\r\n  filters?: ApplicationFilters;\r\n  sortBy?: 'createdAt' | 'updatedAt' | 'name' | 'views' | 'likes';\r\n  sortOrder?: 'asc' | 'desc';\r\n  limit?: number;\r\n}\r\n\r\n// Application Management Service\r\nexport class ApplicationService extends BaseService {\r\n  private readonly COLLECTION_NAME = 'applications';\r\n\r\n  // Create new application\r\n  async createApplication(data: CreateApplicationData): Promise<Application> {\r\n    try {\r\n      const applicationData: Omit<Application, 'id' | 'createdAt' | 'updatedAt' | 'createdBy' | 'updatedBy'> = {\r\n        ...data,\r\n        status: 'draft',\r\n        isPublic: data.isPublic ?? false,\r\n        isFavorite: false,\r\n        tags: data.tags ?? [],\r\n        analytics: {\r\n          views: 0,\r\n          likes: 0,\r\n          forks: 0,\r\n          shares: 0,\r\n        },\r\n      };\r\n\r\n      return await this.createDocument<Application>(this.COLLECTION_NAME, applicationData);\r\n    } catch (error) {\r\n      this.handleError(error, 'createApplication');\r\n    }\r\n  }\r\n\r\n  // Get application by ID\r\n  async getApplication(id: string): Promise<Application | null> {\r\n    try {\r\n      const app = await this.getDocument<Application>(this.COLLECTION_NAME, id);\r\n      \r\n      // Increment view count if app exists and user is not the owner\r\n      if (app && app.createdBy !== this.getCurrentUserId()) {\r\n        await this.incrementAnalytics(id, 'views');\r\n      }\r\n      \r\n      return app;\r\n    } catch (error) {\r\n      this.handleError(error, 'getApplication');\r\n    }\r\n  }\r\n\r\n  // Update application\r\n  async updateApplication(id: string, data: UpdateApplicationData): Promise<void> {\r\n    try {\r\n      // Verify ownership\r\n      const app = await this.getDocument<Application>(this.COLLECTION_NAME, id);\r\n      if (!app) {\r\n        throw new Error('Application not found');\r\n      }\r\n      \r\n      const currentUserId = this.getCurrentUserId();\r\n      if (app.createdBy !== currentUserId) {\r\n        throw new Error('Unauthorized: You can only update your own applications');\r\n      }\r\n\r\n      await this.updateDocument(this.COLLECTION_NAME, id, data);\r\n    } catch (error) {\r\n      this.handleError(error, 'updateApplication');\r\n    }\r\n  }\r\n\r\n  // Delete application\r\n  async deleteApplication(id: string): Promise<void> {\r\n    try {\r\n      // Verify ownership\r\n      const app = await this.getDocument<Application>(this.COLLECTION_NAME, id);\r\n      if (!app) {\r\n        throw new Error('Application not found');\r\n      }\r\n      \r\n      const currentUserId = this.getCurrentUserId();\r\n      if (app.createdBy !== currentUserId) {\r\n        throw new Error('Unauthorized: You can only delete your own applications');\r\n      }\r\n\r\n      await this.deleteDocument(this.COLLECTION_NAME, id);\r\n    } catch (error) {\r\n      this.handleError(error, 'deleteApplication');\r\n    }\r\n  }\r\n\r\n  // Get user's applications\r\n  async getUserApplications(userId?: string): Promise<Application[]> {\r\n    try {\r\n      const targetUserId = userId || this.getCurrentUserId();\r\n      \r\n      return await this.queryDocuments<Application>(\r\n        this.COLLECTION_NAME,\r\n        [\r\n          where('createdBy', '==', targetUserId),\r\n          orderBy('updatedAt', 'desc'),\r\n        ]\r\n      );\r\n    } catch (error) {\r\n      this.handleError(error, 'getUserApplications');\r\n    }\r\n  }\r\n\r\n  // Search applications\r\n  async searchApplications(options: ApplicationSearchOptions = {}): Promise<Application[]> {\r\n    try {\r\n      const constraints: QueryConstraint[] = [];\r\n      \r\n      // Apply filters\r\n      if (options.filters) {\r\n        const { category, framework, status, isPublic, createdBy } = options.filters;\r\n        \r\n        if (category) {\r\n          constraints.push(where('category', '==', category));\r\n        }\r\n        \r\n        if (framework) {\r\n          constraints.push(where('framework', '==', framework));\r\n        }\r\n        \r\n        if (status) {\r\n          constraints.push(where('status', '==', status));\r\n        }\r\n        \r\n        if (isPublic !== undefined) {\r\n          constraints.push(where('isPublic', '==', isPublic));\r\n        }\r\n        \r\n        if (createdBy) {\r\n          constraints.push(where('createdBy', '==', createdBy));\r\n        }\r\n      }\r\n\r\n      // Add ordering\r\n      const sortBy = options.sortBy || 'updatedAt';\r\n      const sortOrder = options.sortOrder || 'desc';\r\n      constraints.push(orderBy(sortBy, sortOrder));\r\n\r\n      // Add limit\r\n      if (options.limit) {\r\n        constraints.push(firestoreLimit(options.limit));\r\n      }\r\n\r\n      let results = await this.queryDocuments<Application>(this.COLLECTION_NAME, constraints);\r\n\r\n      // Client-side text search (in production, consider using Algolia)\r\n      if (options.searchTerm) {\r\n        const searchTerm = options.searchTerm.toLowerCase();\r\n        results = results.filter(app => \r\n          app.name.toLowerCase().includes(searchTerm) ||\r\n          app.description.toLowerCase().includes(searchTerm) ||\r\n          app.tags.some(tag => tag.toLowerCase().includes(searchTerm))\r\n        );\r\n      }\r\n\r\n      // Client-side tag filtering\r\n      if (options.filters?.tags && options.filters.tags.length > 0) {\r\n        results = results.filter(app =>\r\n          options.filters!.tags!.some(tag => app.tags.includes(tag))\r\n        );\r\n      }\r\n\r\n      return results;\r\n    } catch (error) {\r\n      this.handleError(error, 'searchApplications');\r\n    }\r\n  }\r\n\r\n  // Get public applications\r\n  async getPublicApplications(limit = 20): Promise<Application[]> {\r\n    try {\r\n      return await this.queryDocuments<Application>(\r\n        this.COLLECTION_NAME,\r\n        [\r\n          where('isPublic', '==', true),\r\n          where('status', '==', 'deployed'),\r\n          orderBy('updatedAt', 'desc'),\r\n          firestoreLimit(limit),\r\n        ]\r\n      );\r\n    } catch (error) {\r\n      this.handleError(error, 'getPublicApplications');\r\n    }\r\n  }\r\n\r\n  // Get trending applications\r\n  async getTrendingApplications(limit = 10): Promise<Application[]> {\r\n    try {\r\n      return await this.queryDocuments<Application>(\r\n        this.COLLECTION_NAME,\r\n        [\r\n          where('isPublic', '==', true),\r\n          where('status', '==', 'deployed'),\r\n          orderBy('analytics.views', 'desc'),\r\n          firestoreLimit(limit),\r\n        ]\r\n      );\r\n    } catch (error) {\r\n      this.handleError(error, 'getTrendingApplications');\r\n    }\r\n  }\r\n\r\n  // Toggle favorite status\r\n  async toggleFavorite(id: string): Promise<boolean> {\r\n    try {\r\n      const app = await this.getDocument<Application>(this.COLLECTION_NAME, id);\r\n      if (!app) {\r\n        throw new Error('Application not found');\r\n      }\r\n      \r\n      const currentUserId = this.getCurrentUserId();\r\n      if (app.createdBy !== currentUserId) {\r\n        throw new Error('Unauthorized: You can only favorite your own applications');\r\n      }\r\n\r\n      const newFavoriteStatus = !app.isFavorite;\r\n      await this.updateDocument(this.COLLECTION_NAME, id, { isFavorite: newFavoriteStatus });\r\n      \r\n      return newFavoriteStatus;\r\n    } catch (error) {\r\n      this.handleError(error, 'toggleFavorite');\r\n    }\r\n  }\r\n\r\n  // Increment analytics counters\r\n  async incrementAnalytics(\r\n    id: string, \r\n    metric: 'views' | 'likes' | 'forks' | 'shares'\r\n  ): Promise<void> {\r\n    try {\r\n      const app = await this.getDocument<Application>(this.COLLECTION_NAME, id);\r\n      if (!app) {\r\n        throw new Error('Application not found');\r\n      }\r\n\r\n      const currentCount = app.analytics[metric] || 0;\r\n      await this.updateDocument(this.COLLECTION_NAME, id, {\r\n        analytics: {\r\n          ...app.analytics,\r\n          [metric]: currentCount + 1,\r\n        },\r\n      });\r\n    } catch (error) {\r\n      this.handleError(error, 'incrementAnalytics');\r\n    }\r\n  }\r\n\r\n  // Get application categories\r\n  async getCategories(): Promise<string[]> {\r\n    try {\r\n      // In production, you might want to cache this or store in a separate collection\r\n      const apps = await this.queryDocuments<Application>(this.COLLECTION_NAME, [\r\n        where('isPublic', '==', true),\r\n      ]);\r\n      \r\n      const categories = new Set<string>();\r\n      apps.forEach(app => categories.add(app.category));\r\n      \r\n      return Array.from(categories).sort();\r\n    } catch (error) {\r\n      this.handleError(error, 'getCategories');\r\n    }\r\n  }\r\n\r\n  // Get popular tags\r\n  async getPopularTags(limit = 20): Promise<Array<{ tag: string; count: number }>> {\r\n    try {\r\n      const apps = await this.queryDocuments<Application>(this.COLLECTION_NAME, [\r\n        where('isPublic', '==', true),\r\n      ]);\r\n      \r\n      const tagCounts = new Map<string, number>();\r\n      apps.forEach(app => {\r\n        app.tags.forEach(tag => {\r\n          tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);\r\n        });\r\n      });\r\n      \r\n      return Array.from(tagCounts.entries())\r\n        .map(([tag, count]) => ({ tag, count }))\r\n        .sort((a, b) => b.count - a.count)\r\n        .slice(0, limit);\r\n    } catch (error) {\r\n      this.handleError(error, 'getPopularTags');\r\n    }\r\n  }\r\n\r\n  // Clone application (create a copy)\r\n  async cloneApplication(id: string, newName?: string): Promise<Application> {\r\n    try {\r\n      const originalApp = await this.getDocument<Application>(this.COLLECTION_NAME, id);\r\n      if (!originalApp) {\r\n        throw new Error('Application not found');\r\n      }\r\n      \r\n      if (!originalApp.isPublic && originalApp.createdBy !== this.getCurrentUserId()) {\r\n        throw new Error('Cannot clone private application');\r\n      }\r\n\r\n      const cloneData: CreateApplicationData = {\r\n        name: newName || `${originalApp.name} (Copy)`,\r\n        description: originalApp.description,\r\n        category: originalApp.category,\r\n        framework: originalApp.framework,\r\n        isPublic: false, // Clones are private by default\r\n        tags: [...originalApp.tags],\r\n        generationSettings: { ...originalApp.generationSettings },\r\n      };\r\n\r\n      const clonedApp = await this.createApplication(cloneData);\r\n      \r\n      // Increment fork count on original\r\n      await this.incrementAnalytics(id, 'forks');\r\n      \r\n      return clonedApp;\r\n    } catch (error) {\r\n      this.handleError(error, 'cloneApplication');\r\n    }\r\n  }\r\n}"],"names":["ApplicationService","BaseService","constructor","super","arguments","__publicField","this","createApplication","data","applicationData","status","isPublic","isFavorite","tags","analytics","views","likes","forks","shares","createDocument","COLLECTION_NAME","error","handleError","getApplication","id","app","getDocument","createdBy","getCurrentUserId","incrementAnalytics","updateApplication","Error","currentUserId","updateDocument","deleteApplication","deleteDocument","getUserApplications","userId","targetUserId","queryDocuments","where","orderBy","searchApplications","options","constraints","filters","category","framework","push","sortBy","sortOrder","limit","firestoreLimit","results","searchTerm","toLowerCase","filter","name","includes","description","some","tag","length","getPublicApplications","getTrendingApplications","toggleFavorite","newFavoriteStatus","metric","currentCount","getCategories","apps","categories","Set","forEach","add","Array","from","sort","getPopularTags","tagCounts","Map","set","get","entries","map","count","a","b","slice","cloneApplication","newName","originalApp","cloneData","generationSettings","clonedApp"],"mappings":"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"}